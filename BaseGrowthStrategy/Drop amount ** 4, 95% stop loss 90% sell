import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime

# Parameters
initial_investment_lump = 100000  # $100,000 lump sum per asset for lump strategies
initial_investment_dynamic = 50000  # $50,000 per asset for dynamic strategy, total $100,000
max_drop_threshold = 0.40  # Maximum drop percentage to allow buying (e.g., 40%)
UPRO_allocation_threshold = 0.95  # Threshold for UPRO allocation (80% of total)
rebalance_percent = 0.9  # Percentage of total value to rebalance (20%)

# Download historical data for SPY and UPRO
spy = yf.Ticker("SPY").history(period="max")
UPRO = yf.Ticker("UPRO").history(period="max")
data = pd.concat([spy['Close'].rename('SPY'), UPRO['Close'].rename('UPRO')], axis=1).dropna()
data.index = pd.to_datetime(data.index)

# Function to initialize strategies for a given start date
def initialize_strategies(start_date, df):
    # Find the first available date in the period
    available_dates = df.index[df.index >= start_date]
    if not available_dates.empty:
        start_date = available_dates[0]
        start_price_spy = df.loc[start_date, 'SPY']
        start_price_UPRO = df.loc[start_date, 'UPRO']
        strategies = {
            'SPY_Lump': {'shares': initial_investment_lump / start_price_spy, 'value': []},
            'UPRO_Lump': {'shares': initial_investment_lump / start_price_UPRO, 'value': []},
            'Dynamic_Strategy': {
                'spy_shares': initial_investment_dynamic / start_price_spy,
                'UPRO_shares': initial_investment_dynamic / start_price_UPRO,
                'total_value': [],
                'spy_value_history': [],
                'UPRO_value_history': []
            }
        }
        return strategies
    raise ValueError(f"No data available starting from {start_date}")

# Process data for each period
periods = [
    ('2010-01-01', '2014-12-31', '2010-2014'),
    ('2015-01-01', '2019-12-31', '2015-2019'),
    ('2020-01-01', '2025-08-03', '2020-2025')
]

for start_date, end_date, period_title in periods:
    # Filter data for the current period
    period_data = data[(data.index >= start_date) & (data.index <= end_date)].copy()
    
    # Reinitialize strategies for the start of this period
    try:
        strategies = initialize_strategies(start_date, period_data)
    except ValueError as e:
        print(f"Error for period {period_title}: {e}")
        continue
    
    # Process each day in the period
    for i in range(len(period_data)):
        date = period_data.index[i]
        spy_price = period_data['SPY'].iloc[i]
        UPRO_price = period_data['UPRO'].iloc[i]
        
        # Lump sum baselines (no rebalancing)
        spy_lump_value = strategies['SPY_Lump']['shares'] * spy_price
        strategies['SPY_Lump']['value'].append(spy_lump_value)
        UPRO_lump_value = strategies['UPRO_Lump']['shares'] * UPRO_price
        strategies['UPRO_Lump']['value'].append(UPRO_lump_value)
        
        # Dynamic Strategy
        strategy = strategies['Dynamic_Strategy']
        
        # Calculate current values
        current_spy_value = strategy['spy_shares'] * spy_price
        current_UPRO_value = strategy['UPRO_shares'] * UPRO_price
        total_value = current_spy_value + current_UPRO_value
        
        # Check UPRO allocation threshold
        if total_value > 0 and (current_UPRO_value / total_value) >= UPRO_allocation_threshold:
            move_amount = total_value * rebalance_percent  # Use rebalance_percent of total value
            if move_amount > 0 and current_UPRO_value >= move_amount:
                shares_to_sell = move_amount / UPRO_price
                strategy['UPRO_shares'] -= shares_to_sell
                strategy['spy_shares'] += move_amount / spy_price
        
        # Calculate daily percentage change in UPRO
        if i > 0:
            prev_UPRO_price = period_data['UPRO'].iloc[i-1]
            higher_price = max(UPRO_price, prev_UPRO_price)
            price_change = UPRO_price - prev_UPRO_price
            move_percent = price_change / higher_price if higher_price > 0 else 0  # Avoid division by zero
            
            # Rebalance based on UPRO percentage change
            if move_percent != 0:  # Avoid no change
                if UPRO_price < prev_UPRO_price:  # UPRO dropped
                    drop_percent = (prev_UPRO_price - UPRO_price) / prev_UPRO_price  # Drop percentage
                    if drop_percent <= max_drop_threshold:  # Only buy if drop is within threshold
                        move_percent = 1 - (1 - drop_percent) ** 4  # Formula for drop
                        current_spy_value = strategy['spy_shares'] * spy_price
                        move_amount = current_spy_value * move_percent
                        if move_amount > 0 and current_spy_value >= move_amount:
                            shares_to_sell = move_amount / spy_price
                            strategy['spy_shares'] -= shares_to_sell
                            strategy['UPRO_shares'] += move_amount / UPRO_price
                elif UPRO_price > prev_UPRO_price:  # UPRO increased
                    current_UPRO_value = strategy['UPRO_shares'] * UPRO_price
                    move_amount = current_UPRO_value * abs(move_percent)
                    if move_amount > 0 and current_UPRO_value >= move_amount:
                        shares_to_sell = move_amount / UPRO_price
                        strategy['UPRO_shares'] -= shares_to_sell
                        strategy['spy_shares'] += move_amount / spy_price
        
        # Record daily values after rebalancing
        spy_daily_value = strategy['spy_shares'] * spy_price
        UPRO_daily_value = strategy['UPRO_shares'] * UPRO_price
        total_value = spy_daily_value + UPRO_daily_value
        strategy['spy_value_history'].append(spy_daily_value)
        strategy['UPRO_value_history'].append(UPRO_daily_value)
        strategy['total_value'].append(total_value)
    
    # Create DataFrame for portfolio values for this period
    portfolio_data = {
        'SPY_Lump': strategies['SPY_Lump']['value'],
        'UPRO_Lump': strategies['UPRO_Lump']['value'],
        'Dynamic_Total': strategies['Dynamic_Strategy']['total_value'],
        'Dynamic_SPY': strategies['Dynamic_Strategy']['spy_value_history'],
        'Dynamic_UPRO': strategies['Dynamic_Strategy']['UPRO_value_history']
    }
    portfolio_df = pd.DataFrame(portfolio_data, index=period_data.index)
    
    # Plot results for the current period
    plt.figure(figsize=(14, 7))
    plt.plot(portfolio_df.index, portfolio_df['SPY_Lump'], label='Lump Sum $100k in SPY', color='blue')
    plt.plot(portfolio_df.index, portfolio_df['UPRO_Lump'], label='Lump Sum $100k in UPRO', color='red')
    plt.plot(portfolio_df.index, portfolio_df['Dynamic_Total'], label='Dynamic Total Value', color='green')
    plt.plot(portfolio_df.index, portfolio_df['Dynamic_SPY'], label='Dynamic SPY Value', color='cyan', linestyle='--')
    plt.plot(portfolio_df.index, portfolio_df['Dynamic_UPRO'], label='Dynamic UPRO Value', color='magenta', linestyle='--')
    plt.xlabel('Date')
    plt.ylabel('Portfolio Value (USD)')
    plt.title(f'Lump Sum and Dynamic Strategy Comparison: SPY vs UPRO ({period_title})')
    plt.grid(True)
    plt.legend(loc='upper left')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.show()

# Print final portfolio values to terminal
print("\n=== Lump Sum and Dynamic Strategy Results ===")
print(f"Final Values as of {data.index[-1].date()} at 04:47 PM +08:")
print(f"Lump Sum SPY: ${portfolio_df['SPY_Lump'].iloc[-1]:,.2f}")
print(f"Lump Sum UPRO: ${portfolio_df['UPRO_Lump'].iloc[-1]:,.2f}")
print(f"Dynamic Total: ${portfolio_df['Dynamic_Total'].iloc[-1]:,.2f}")
print(f"Dynamic SPY: ${portfolio_df['Dynamic_SPY'].iloc[-1]:,.2f}")
print(f"Dynamic UPRO: ${portfolio_df['Dynamic_UPRO'].iloc[-1]:,.2f}")
